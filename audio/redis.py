# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_redis.ipynb.

# %% auto 0
__all__ = ['get_inner_redis', 'get_stream_redis', 'StreamItem', 'ApiConnection', 'Data', 'Audio', 'Transcript', 'Diarisation']

# %% ../nbs/00_redis.ipynb 3
import redis.asyncio as aioredis
from pydantic import BaseModel
from typing import Optional,Union,List, Literal
from dataclasses import dataclass
import redis
import json

# %% ../nbs/00_redis.ipynb 4
async def get_inner_redis():
    
    db = await aioredis.from_url(
            "redis://redis:6379/0",decode_responses=True
        )

    await db.ping()

    return db

# %% ../nbs/00_redis.ipynb 5
async def get_stream_redis():
    
    db = await aioredis.from_url(
            "redis://host.docker.internal:6380/0",decode_responses=True
        )

    await db.ping()

    return db

# %% ../nbs/00_redis.ipynb 12
class StreamItem(BaseModel):
    chunk: bytes
    timestamp: Optional[str] = None

    def dump(self):
        chunk = self.chunk.hex()
        self.timestamp =  str(datetime.utcnow())


        return {
                "chunk": chunk,
                "timestamp":self.timestamp
                }

    @classmethod
    def load(cls, item):
        item = json.loads(item)
        chunk = bytes.fromhex(item['chunk'])
        return cls(chunk=bytes.fromhex(item['chunk']), timestamp=item['timestamp'])


# %% ../nbs/00_redis.ipynb 13
class ApiConnection:
    """
    connection to initial chrome extention feed
    """
    def __init__(self, conn_id, redis_client,is_video=False):
        self.id = conn_id
        self.redis_client = redis_client
        self.is_video = is_video
        self.name = f"Connection:{self.id}"
        self.start_timestamp = pd.Timestamp.utcnow()
        self.queue = f"initialFeed_audio:{self.id}"
        self.__post_init__()

    def __post_init__(self):
        if self.is_video:self.queue = f"initialFeed:{self.id}"
        else:            self.queue = f"initialFeed_audio:{self.id}"

    async def set_open(self):
            self.open = True
            await self.set_update()

    async def set_closed(self):
        self.open = False
        await self.set_update()

    async def set_update(self):
        await self.redis_client.hset(self.name, 'open', int(self.open))

    async def enqueue(self, message):
        await self.redis_client.lpush(self.queue, json.dumps(message))

    async def check_open(self):
        self.open = bool(int(await self.redis_client.hget(self.name, 'open')))
        return self.open
    
    async def delete(self):
        await self.redis_client.delete(self.name)
        await self.redis_client.delete(self.queue)

    async def pop_multiple(self, max_len, min_len=1):
        lua_script = """
        local items = {}
        for i = 1, tonumber(ARGV[1]) do
            local item = redis.call('rpop', KEYS[1])
            if item == nil then
                break
            end
            table.insert(items, item)
        end
        return items
        """
        if await self.redis_client.llen(self.queue) >= min_len:
            items = await self.redis_client.eval(lua_script, 1, self.queue, max_len)
            items = [i for i in items if i]
            return [StreamItem.load(i) for i in items]
        
    async def get_queue_length(self):
        return await self.redis_client.llen(self.queue)
    
    async def get_all_queue(self):
        items =  await self.redis_client.lrange(self.queue, 0, -1)
        items = [i for i in items if i]
        return [StreamItem.load(i) for i in items]
    

    



# %% ../nbs/00_redis.ipynb 14
@dataclass
class Data:
    chunk_name:str
    key:Literal['audio','transcription','diarisation']
    redis_client: redis.client.Redis
    data: Union[List, bytes]=None
    

    async def save(self):
            if isinstance(self.data, bytes): 
                data = self.data.hex()
            else: 
                data = json.dumps(self.data)
            await self.redis_client.hset(self.chunk_name, self.key, data)

    async def get(self):
        data = await self.redis_client.hget(self.chunk_name, self.key)
        if data:
            if self.key == 'audio': 
                self.data = bytes.fromhex(data)
            else: 
                self.data = json.loads(data)
        else: 
            self.data = None
        return bool(data)

    
    async def delete(self):
        return bool(await self.redis_client.delete(self.chunk_name))



class Audio(Data):
    def __init__(self, chunk_name: str, redis_client: redis.client.Redis, data: bytes = None):
        super().__init__(chunk_name=chunk_name, key='audio', redis_client=redis_client, data=data)

    async def fix(self):
        self.data = await asyncio.to_thread(fix_mp3_data, self.data)
        

class Transcript(Data):
    def __init__(self, chunk_name: str, redis_client: redis.client.Redis, data: List = None):
        super().__init__(chunk_name=chunk_name, key='transcription', redis_client=redis_client, data=data)

class Diarisation(Data):
    def __init__(self, chunk_name: str, redis_client: redis.client.Redis, data: List = None):
        super().__init__(chunk_name=chunk_name, key='diarisation', redis_client=redis_client, data=data)

