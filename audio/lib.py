# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00.ipynb.

# %% auto 0
__all__ = ['get_inner_redis', 'list_directory_contents', 'log', 'average_embeddings', 'pairwise_cosine_similarity', 'path_info']

# %% ../nbs/00.ipynb 6
import sys 
from .redis import *

import redis
from pathlib import Path
try:
    import torch
    import torch.nn.functional as F

except:
    pass
import csv
from datetime import datetime
import os


# %% ../nbs/00.ipynb 7
def get_inner_redis():
    
    db = redis.from_url(
            "redis://redis:6379",decode_responses=True
        )

    db.ping()

    return db

# %% ../nbs/00.ipynb 8
def list_directory_contents(path='.'):
    """
    Lists the contents of a directory using pathlib.

    :param path: The directory path to list contents of. Defaults to the current directory.
    :return: None
    """
    p = Path(path)
    return [entry for entry in p.iterdir()]


# %% ../nbs/00.ipynb 9
def log(*args,file_path=None):
    """
    Logs the provided arguments into a CSV file along with a current timestamp.

    Parameters:
    - file_path: str, the path to the CSV file where data should be logged. Defaults to 'log.csv' in the current directory.
    - *args: variable length argument list, the data to log in the CSV.
    """

    # Get the current timestamp
    now = datetime.now()
    timestamp = now.strftime('%Y-%m-%d %H:%M:%S')

    if file_path is None:
        script_name = os.path.basename(sys.argv[0])
        if script_name.endswith('.py'):
            script_name = script_name[:-3]  # Remove .py extension
        file_path = f"logs/{script_name}_log.csv"

    # Open the CSV file and append the new row
    with open(file_path, mode='a', newline='') as file:
        writer = csv.writer(file)
        # Add the timestamp as the first item in the row, followed by the provided arguments
        writer.writerow([timestamp] + list(args))

    print([timestamp] + list(args))

# %% ../nbs/00.ipynb 10
def average_embeddings(embeddings):
    """
    Averages embeddings along the second dimension.

    :param embeddings: A 3D tensor of shape (num_slices, num_embeddings, embedding_dim)
                       where num_slices is the number of time slices,
                       num_embeddings is the number of embeddings per time slice,
                       and embedding_dim is the dimensionality of each embedding.
    :return: A 2D tensor of shape (num_slices, embedding_dim) representing the averaged
             embeddings for each time slice.
    """
    return torch.mean(embeddings, dim=1)

def pairwise_cosine_similarity(embeddings):
    """
    Calculate the pairwise cosine similarity of a set of averaged embeddings.

    :param embeddings: A 2D tensor of shape (num_slices, embedding_dim)
                       where num_slices is the number of time slices and
                       embedding_dim is the dimensionality of the averaged embeddings.
    :return: A 2D tensor of shape (num_slices, num_slices) containing
             the pairwise cosine similarity scores between slices.
    """
    embeddings_norm = F.normalize(embeddings, p=2, dim=1)
    similarity_matrix = torch.mm(embeddings_norm, embeddings_norm.t())
    
    return similarity_matrix



# %% ../nbs/00.ipynb 11
from pathlib import Path
import pandas as pd
import os

def path_info(path: Path = Path.cwd()):
    # Initialize the list to hold file information
    files_info = []

    # Iterate through each file in the given directory
    for file in Path(path).iterdir():
        if file.is_file():  # Ensure we're only including files
            files_info.append({
                "name": file.name,
                "size": file.stat().st_size,
                "created": pd.to_datetime(file.stat().st_ctime, unit='s'),
                "modified": pd.to_datetime(file.stat().st_mtime, unit='s'),
                "path": file  # Add the full path as a Pathlib object
            })

    # Convert the list to a DataFrame and return it
    return pd.DataFrame(files_info)

