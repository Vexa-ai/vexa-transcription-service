# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_audio.ipynb.

# %% auto 0
__all__ = ['AudioSlicer']

# %% ../nbs/00_audio.ipynb 2
import asyncio
from pydub import AudioSegment
import io
import subprocess

# %% ../nbs/00_audio.ipynb 3
class AudioSlicer:
    def __init__(self, data=None, format="mp3"):
        self.format = format
        self.audio = AudioSegment.from_file(io.BytesIO(data), format=format) if data is not None else None

    
    @classmethod
    async def from_file(cls, file_path, format="mp3"):
        def read_file(file_path):
            with open(file_path, "rb") as file:
                return file.read()

        data = await asyncio.to_thread(read_file, file_path)
        return cls(data, format)

    async def export2file(self, export_path, start=None, end=None):
        def export(segment, export_path):
            segment.export(export_path, format=self.format)

        segment = self.slice(start, end)
        await asyncio.to_thread(export, segment, export_path)

    async def export_data(self, start=None, end=None,format='mp3'):
        def export(segment, buffer):
            segment.export(buffer, format=format)
            return buffer.getvalue()

        segment = self.slice(start, end)
        buffer = io.BytesIO()
        return await asyncio.to_thread(export, segment, buffer)

    # slice remains synchronous as it's a simple in-memory operation
    def slice(self, start=None, end=None):

        if start is not None:
            start_millis = start * 1000
            end_millis = end * 1000
            audio = self.audio[start_millis:end_millis]
        else:
            print(start)
            audio = self.audio

        return audio
    
    async def append(self, additional_data):
        def append_(additional_data):
            new_segment = AudioSegment.from_file(io.BytesIO(additional_data), format=self.format)
            self.audio += new_segment

        await asyncio.to_thread(append_, additional_data)

    def append_raw_audio(self, raw_data):
        frame_rate = self.audio.frame_rate
        sample_width = self.audio.sample_width
        channels = self.audio.channels
        frame_size = sample_width * channels

        # Ensure the data length is a multiple of the frame size
        aligned_data_length = len(raw_data) - (len(raw_data) % frame_size)
        aligned_data = raw_data[:aligned_data_length]

        new_segment = AudioSegment(
            data=aligned_data,
            sample_width=sample_width,
            frame_rate=frame_rate,
            channels=channels
        )
        self.audio = self.audio + new_segment


