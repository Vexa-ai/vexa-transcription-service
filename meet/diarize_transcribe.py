# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_audio_processor_from_file.ipynb.

# %% auto 0
__all__ = ['redis_inner_client', 'redis_stream_client', 'client_id', 'diarize_ready_notification',
           'transcribe_ready_notification', 'Notification', 'diarize', 'transcribe']

# %% ../nbs/03_audio_processor_from_file.ipynb 1
from audio.redis import *
from audio.audio import *
# from audio.paths import *
# from audio.tools import *
# from audio.psql import *

from pathlib import Path
import json

import uuid

import pandas as pd

import redis
import asyncio
import redis.asyncio as aioredis
from dataclasses import dataclass
import numpy as np

# %% ../nbs/03_audio_processor_from_file.ipynb 3
redis_inner_client = await get_inner_redis()
redis_stream_client = await get_stream_redis()
client_id = '851f343e-4954-4f0a-8835-9664cc91c181'

# %% ../nbs/03_audio_processor_from_file.ipynb 4
@dataclass
class Notification:
    channel_name: str
    redis_client: aioredis.Redis

    async def initialize(self):
     #   self.redis_client = await get_inner_redis()
        async with self.redis_client.pubsub() as sub:
            await sub.subscribe(self.channel_name)

    async def wait(self, msg):
        async with self.redis_client.pubsub() as sub:
            await sub.subscribe(self.channel_name)
            while True:
                r = await sub.get_message(ignore_subscribe_messages=True)
                if r and r['data'] == msg:
                    print('done')
                    break
                await asyncio.sleep(0)  # Yield control

# %% ../nbs/03_audio_processor_from_file.ipynb 5
diarize_ready_notification = Notification('DiarizeReady',redis_inner_client)
await diarize_ready_notification.initialize()
transcribe_ready_notification = Notification('TranscribeReady',redis_inner_client)
await transcribe_ready_notification.initialize()

# %% ../nbs/03_audio_processor_from_file.ipynb 6
async def diarize(audio_data, client_id, audio_name, shift):
    audio = Audio(chunk_name=audio_name, redis_client=redis_inner_client, data=audio_data)
    await audio.save()
    await redis_inner_client.lpush('Audio2DiarizeQueue', f'{audio_name}:{client_id}')
    await diarize_ready_notification.wait(audio_name)
    diarization = Diarisation(audio_name, redis_inner_client)
    await diarization.get()
    df = pd.DataFrame(diarization.data)
    df['silence'] = df['start']-df['end'].shift()
    df['speaker_change'] = df['speaker'] != df['speaker'].shift()
    df['len'] = df['end'] - df['start']
    df = df[df['len'] > 0.5]
    df['speaker_change'] = np.where(df['silence']>2,True,df['speaker_change'])

    df['speaker_change'] = df['speaker_change'].cumsum()
    df = df.groupby('speaker_change').agg({'speaker': 'first', 'start': 'first', 'end': 'last'})
    df['conv_start'] = df['start'] + shift
    df['conv_end'] = df['end'] + shift
    return df.to_dict('records')

# %% ../nbs/03_audio_processor_from_file.ipynb 7
async def transcribe(diarization_result,connection_id,audio_name):
    for segment in diarization_result:
        segment['connection_id'] = connection_id
        segment['name'] = str(uuid.uuid4())
        segment['audio_id'] = audio_name
        await redis_inner_client.lpush('TranscribeQueue', json.dumps(segment))
        await transcribe_ready_notification.wait(segment['name'])
       # wait_notification(transcribe_ready_notification,segment['name'])
        transcription = Transcript(segment["name"],redis_inner_client)
        await transcription.get()
        segment['transcription'] = transcription.data
        await redis_inner_client.lpush(f'Segment:{connection_id}', json.dumps(segment))
        await redis_inner_client.publish(f'SegmentReady', segment["name"])
